# Introduction

This library provides an easy and powerful way to use nested children
components in your Elm program with very little boilerplate. Parent
components can easily communicate with children components and react to
any changes that might occur in them.

You can nest components to any depth and the components are just
regular Elm programs, the the usual 
Children components are just regular Elm programs with the usual `Msg`, `Model`, `update`,
`view`, `subscription`, that can be tested individually, and can be
nested to any depth.

The only boilerplate you need to add to the parent, in order for it
to handle any number or variety of components, is an extra message
constructor in your `Msg` that takes an `Updater`:

```elm
type Msg = ...
         | UpdaterMsg (Updater Model Msg)
```

Then, in your `update` function, you just have to add one line to
handle the updater message type, which applies the updater to your
current model:

```elm
update msg model = case msg of
                      ...
                      UpdaterMsg u -> u model

```

`Updater`s are generated by `Converter`s that have been applied to a child
component's message type. To make a converter for a child component,
you just need to declare an `Interface` with the following information:

* `get` - how to get the child component's model from the parent model.
* `set` - how to update the child component's model within the parent model.
* `update` - the child component's standard `update` function.
* `react` - (optional) lets the parent react to any of the children's messages.

Once defined, a `Converter` can be used with `Html.map`, `Sub.map`, or
`Cmd.map` to convert any `Html`, `Sub`, or `Cmd` containing the child
component's message type. Just `map` the converter onto the child
message and `Updater` will take care of the rest.

This library makes using nested components easy and efficient.
It should encourage the creation and sharing of re-usable, decoupled,
components.
It also allows for some really nice abstractions, like the `Many`
component (shown as in examples far below), which lets you easily
create and display a collection of any component, without having to worry about the
underlying implementation.

# Examples

### Prelude

There will be three stock components that we use to build up more
complicated components:

* `EditableLabel` is a label that can be changed with an edit button
(demo, source)
* `Timer` is a standard kitchen timer that counts down from whatever
  you set and flashes when it reaches zero (demo, source)
* `SuperBuzzer` is just a bigger, animated "buzzer" that really grabs
your attention (demo, source)

## TaskTimer

A `TaskTimer` is just a kitchen timer with a task name and
description. The idea is that later we will use many of them to make a
timed todo list. We'll also make each `TaskTimer` display the number of times it has
buzzed.

First, the module name and imports:

```elm
module Component.TaskTimer exposing (Msg (Reset, BuzzMessage), Model, init, update, view, subscriptions)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.App as Html
import Updater exposing (converter, Updater, Converter, Interface, toCmd, noReaction)

import Component.Timer as Timer
import Component.EditableLabel as Label
```

#### Model

For the `Model`, we'll include the `Timer`, two `Label`s, and a
`buzzCount`:

```elm
type alias Model = { timer : Timer.Model
                   , name : Label.Model
                   , task : Label.Model
                   , buzzCount : Int }
```

#### Msg

Since the `TaskTimer` is meant to be useful child component, we'll
have to make some useful messages for whatever parent will be using.
Let's make a `Reset` message that will reset the `Timer`s clock, and a
`BuzzMessage` message that will occur whenever the `Timer` buzzes, and
will send out the `name` and `task` description. We'll also add in the
`Updater` message:

```elm
type Msg = Reset
         | BuzzMessage String String
         | UpdaterMsg (Updater Model Msg)
```

#### Converters

Now it's time to define the `Converter` interfaces for each of the
children components. The function `converter` takes an updater message
constructor (`UpdaterMsg` in our case, though we could have named it
anything), and an `Interface`, which is defined in the `Updater`
module as:

```elm
type alias Interface pModel pMsg cModel cMsg =
    { get : ( pModel -> Maybe cModel )
    , set : ( cModel -> pModel -> pModel )
    , update : ( cMsg -> cModel -> ( cModel, Cmd cMsg ) )
    , react : ( cMsg -> cModel -> pModel -> ( pModel, Cmd pMsg ) ) }
```

`pModel` and `pMsg` are the parent's `Model` and `Msg`, while `cModel`
and `cMsg` are the child component's.

The `react` function is given any of the child component's
messages and the child's model (already updated with that message), as
well as the parent's model.

Here are the converters for both the `name` and `task` labels:

```elm
nameC : Converter Msg Label.Msg
nameC = converter
        UpdaterMsg
        { get = Just << .name
        , set = (\ cm m -> { m | name = cm } )
        , update = Label.update
        , react = noReaction }

taskC : Converter Msg Label.Msg
taskC = converter
        UpdaterMsg
        { get = Just << .task
        , set = (\ cm m -> { m | task = cm } )
        , update = Label.update
        , react = noReaction }
```

The `set` functions are just the standard Elm record updating syntax.
The `get` function results are wrapped in a `Maybe`, which is
necessary when getting children models out of `Dict` or `Array`. Here
we compose the record getting syntax with a `Just`.

We don't need to react to anything that the labels do. To access their
text we can just reach directly into their models using
`model.task.text` or `model.name.text`. The `noReaction` function is defined in
the `Updater` module and always returns `(model, Cmd.none)`.

Now let's define `timerC` for the timer. The `get` and `set` will be
similar. This time wewant to react to its messages: whenever we see the `Timer.Buzz`
message, we'll increment the `buzzCount` and have the `TaskTimer` trigger
a `BuzzMessage` message:

```elm
timerC : Converter Msg Timer.Msg
timerC = converter
         UpdaterMsg
         { get = Just << .timer
         , set = (\ cm m -> { m | timer = cm } )
         , update = Timer.update
         , react = (\ tmsg _ model ->
                         case tmsg of
                             Timer.Buzz ->
                                 { model | buzzCount = model.buzzCount + 1 }
                                 ! [ toCmd <| BuzzMessage model.name.text model.task.text ]
                             _ -> model ! [] ) }
```

The `toCmd` function is part of the `Updater` module and uses `Task.perform` to box
any message into a `Cmd`, which lets you send messages to the `update`
function, and, as we'll see below, directly to any child components.

#### view

The view function is pretty normal. Everytime we want to display a
child component's model, we'll pass its model into its `view`
function. For example, to display the timer, we can call:

```elm
Timer.view model.timer
```
This, however, will return an `Html Timer.Msg`, which we need to
convert to an `Html Msg`. We can do this using `Html.map` and the
`timerC` converter we defined above:

```elm
Html.map timerC <| Timer.view model.timer
```

Notice that we manually call `Timer.view`, so if the `Timer` module
has some other, more advanced `view` function that takes other
arguments, we could still use that, or we could wrap the `Timer.view`
in custom `Html` tags with `Timer.Msg` events. Whatever we write, it just
needs to return an `Html Timer.Msg` before we
convert it with `Html.map timerC`.

Here's the complete `view` function with all three child components.
Most of the bloat comes from my sloppy CSS:

```elm
view : Model -> Html Msg
view model =
  div [ style [ ("border", "1px solid #aaa"), ("margin", "10px")
              , ("width", "175px"), ("padding", "10px")
              , ("float", "left"), ("height", "320px")] ]
      [ Html.map timerC <| Timer.view model.timer
      , div [] [ h3 [] [text "Name:"]
               , Html.map nameC <| Label.view model.name ]
      , div [] [ h3 [] [text "Description:"]
               , Html.map taskC <| Label.view model.task ]

      , h4 [] [ text <| "Times Buzzed: " ++ toString model.buzzCount ]
      ]
```
#### update

The `update` function only needs to handle three options. One of them
is the `UpdaterMsg`, which only needs to apply the updater to the
current model. Another is `BuzzMessage`, which is just an informative
broadcast.

`Reset` is a command for a parent to reset the `Timer` of the
`TaskTimer`. One option would be to directly update the model of the
`Timer` using Elm's record updating syntax, but that would be tedius
and sloppy.
`Timer.Msg` already has a `Stop` message that does what we want. To
send it to the `timer`, we need to turn `Timer.Stop` into a `Cmd`
using `toCmd`, then convert it using `Cmd.map` and the `timerC`
converter:

```elm
Cmd.map timerC <| toCmd Timer.Stop
```

Here's the complete `update` function:

```elm
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  case msg of
      Reset -> model ! [ Cmd.map timerC <| toCmd Timer.Stop ]

      BuzzMessage _ _ -> model ! []

      UpdaterMsg u -> u model
```

#### subscriptions

The `Label` components don't use any subscriptions, but the `Timer`
component needs subscriptions sometimes to count down every second.
`Timer.subscriptions` returns `Sub Timer.Msg`, which we can convert
using `Sub.map timerC`:

```elm
subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.map timerC <| Timer.subscriptions model.timer
```

#### init

The `Label` components export `initModel` functions, which take an
initial label text string as an argument.

The `Timer` component exports a standard `init` function that returns

```elm
(Timer.Model, Cmd Timer.Msg)
```

The `Cmd`s that `Timer.init` returns are because the creator of the
timer component thought it would be a good idea to have a random
initial starting value between 1 and 30 seconds, so it calls some
`Random` tasks right away to generate them. We need to include these
`Cmd`s and convert them using `timerC`.

```elm
init : (Model, Cmd Msg)
init = let ( tmodel, tcmd ) = Timer.init
       in
           { timer = tmodel
           , task = Label.initModel "Enter a task description here."
           , name = Label.initModel "Timer Name"
           , buzzCount = 0 }
    ! [ Cmd.map timerC tcmd ]
```

#### main

```elm
main : Program Never
main =
    Html.program { init = init
                 , update = update
                 , subscriptions = subscriptions
                 , view = view }
```

That's it! Now you can compile and test `TaskTimer` as an individual
module (demo, source).

## TaskTimer Cluster

What if we want to have a whole bunch of `TaskTimer`s, like an
unlimited amount of them that the user can add or delete at will?

I'll show you two ways to do this. First, a tedious way that uses a
`Dict`, like I'm sure you've done before if you've worked with Elm
much. Second, I'll show you the `Many` component, which abstracts away
the boring part and can be used on any other type of component.

### The Tedious Way

#### module and imports

```elm
module Component.ManualTimerCluster exposing (Msg (..), Model, init, update, view)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.App as Html
import Html.Events exposing ( onClick )
import Dict exposing (Dict)
import Updater exposing (converter, Updater, Converter, Interface, toCmd, noReaction)

import Component.TaskTimer as TaskTimer
```

#### model and message

We'll use a `Dict` to store the `TaskTimer`s and give each of them a
unique id. We'll add `AddTimer` and `DeleteTimer` messages that adds
or deletes the timers from the `Dict`.

`newID` will store the next unused id, and will increment every time a
new timer is added.

```elm
type alias Model = { timers : Dict Int TaskTimer.Model
                   , newID : Int }


type Msg = AddTimer (TaskTimer.Model, Cmd TaskTimer.Msg)
         | DeleteTimer Int
         | UpdaterMsg (Updater Model Msg)

```

Note that `AddTimer` basically takes the result of `TaskTimer.init` as
an argument.

#### Timer Converter

The `TaskTimer` models are stored inside a `Dict`, so we'll have to
have the converter's `get` and `set` functions reach into the `Dict`.
The converter will also need to take an `Int` id as an argument to
know which `TaskTimer` in the `Dict` we want to access.

```elm
timerC : Int -> Converter Msg TaskTimer.Msg
timerC n = converter
           UpdaterMsg
           { get = (\ model -> Dict.get n model.timers)
           , set = (\ timer model -> { model | timers = Dict.insert n timer model.timers } )
           , update = TaskTimer.update
           , react = noReaction }
```

Now we can just call `timerC 5` and get a `Converter` for the
`TaskTimer` stored with the id of `5`.

#### init

The `init` is easy because it starts with nothing in the `Dict`:

```elm
init : (Model, Cmd Msg)
init = { timers = Dict.empty
       , newID = 0 }
    ! [ ]
```

#### update

For the `update` function, `DeleteTimer id` just needs to remove the
timer from the `Dict`.

For `AddTimer`, it just needs to:

* add the new timer's init model to the `Dict`
* increment the `newID` record
* because `TaskTimer.init` sends out some initial `Cmd`s to get a
random starting value for its `Timer`, we need to use `timerC` with the new
`TaskTimer`'s id to use the messages on the new entry.

```elm
update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
  case msg of
      AddTimer (timerModel, timerCmd) ->
          { model | timers = Dict.insert model.newID timerModel model.timers
          , newID = model.newID + 1 }
          ! [ Cmd.map (timerC model.newID) <| timerCmd ]

      DeleteTimer id -> { model | timers = Dict.remove id model.timers } ! []

      UpdaterMsg u -> u model
```

#### subscriptions

For the subscriptions, we just need to map through the `TaskTimer`s in
the dict, converting each subscription by id:

```elm
subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.batch <| List.map (\ (id, timerModel) ->
                              Sub.map (timerC id) <| TaskTimer.subscriptions timerModel )
                    (Dict.toList model.timers)
```

#### view

For the `view`, we will just iterate through a `toList` of the `Dict`,
use `TaskTimer.view` on each model and map `timerC` with the `id` to
convert. We'll also use the `id` to wrap each timer with a delete
button that calls the `DeleteTimer` message.

There's also an "Add Timer" button that just returns the `Addtimer`
message with `TaskTimer.init` as an argument.

```elm
view : Model -> Html Msg
view model =
  div [ ]
      [ div [ style [("height", "420px")]] <|
            List.map (\ (id, timerModel) ->
                          deletableTimer id <|
                          Html.map (timerC id) <| TaskTimer.view timerModel)
            (Dict.toList model.timers)
      , div [] [ button [ onClick <| AddTimer TaskTimer.init ] [ text "Add Timer" ] ]
      ]

deletableTimer : Int -> Html Msg -> Html Msg
deletableTimer id html = div [ style [ ("width", "215px")
                                     , ("float", "left")
                                     , ("height", "320px") ] ]
               [ html
               , button [ onClick <| DeleteTimer id ] [ text "Delete" ]
               ]
```

#### main

```elm
main : Program Never
main =
    Html.program { init = init
                 , update = update
                 , subscriptions = subscriptions
                 , view = view }
```

That's it! Another fully functional component (demo, source).

## TaskTimer Cluster using Many

Using a `Dict` isn't too bad for one collection, but imagine you had a
page with many different collections of components. Think how bloated
your code might become from all the calls to `Dict.toList`, and how
many `AddThis` and `RemoveThat` messages you might have to create!

Using the `Many` component, we can abstract this `Dict`-handling, and
more-easily and succinctly handle collections of components.

